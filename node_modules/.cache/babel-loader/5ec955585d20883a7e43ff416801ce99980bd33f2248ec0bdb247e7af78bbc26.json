{"ast":null,"code":"import { resolveComponent as _resolveComponent, createVNode as _createVNode, openBlock as _openBlock, createElementBlock as _createElementBlock } from \"vue\";\nexport function render(_ctx, _cache, $props, $setup, $data, $options) {\n  const _component_highcharts = _resolveComponent(\"highcharts\");\n  return _openBlock(), _createElementBlock(\"div\", null, [_createVNode(_component_highcharts, {\n    \"constructor-type\": 'stockChart',\n    class: \"hc\",\n    options: $data.chartOptions,\n    ref: \"chart\"\n  }, null, 8, [\"options\"])]);\n}","map":{"version":3,"names":["_createElementBlock","_createVNode","_component_highcharts","class","options","$data","chartOptions","ref"],"sources":["/Users/rashmee/Desktop/usagm/heatmap/src/components/MainHeatMap.vue"],"sourcesContent":["<template>\n  <div>\n    <highcharts\n      :constructor-type=\"'stockChart'\"\n      class=\"hc\"\n      :options=\"chartOptions\"\n      ref=\"chart\"\n    ></highcharts>\n  </div>\n</template>\n\n<script>\nimport moment from \"moment\";\n\nexport default {\n  props: {\n    chartData: {\n      type: Array,\n      default: () => [],\n    },\n    divisionProp: {\n      type: String,\n      default: \"division\",\n    },\n    serviceProp: {\n      type: String,\n      default: \"service\",\n    },\n    profileNameProp: {\n      type: String,\n      default: \"profile_name\",\n    },\n    reportDateProp: {\n      type: String,\n      default: \"report_date\",\n    },\n    videoViewsProp: {\n      type: String,\n      default: \"insight_video_views\",\n    },\n  },\n  data() {\n    return {\n      chartOptions: {\n        chart: {\n          backgroundColor: \"#fbfcf8\",\n          type: \"heatmap\",\n          plotBorderWidth: 1,\n          height: \"100%\",\n          margin: [0, 0, 0, 0],\n        },\n        title: {\n          text: \"Video Views\",\n          align: \"center\",\n        },\n        exporting: {\n          enabled: true,\n          buttons: {\n            contextButton: {\n              menuItems: [\n                \"viewFullscreen\",\n                \"printChart\",\n                \"separator\",\n                \"downloadPNG\",\n                \"downloadJPEG\",\n                \"separator\",\n                \"downloadPDF\",\n                \"downloadCSV\",\n              ],\n            },\n          },\n        },\n        credits: {\n          enabled: false,\n        },\n        legend: {\n          enabled: true,\n          itemStyle: {\n            color: \"#000\",\n          },\n        },\n        rangeSelector: {\n          enabled: false,\n        },\n        navigator: {\n          enabled: false,\n        },\n        scrollbar: {\n          enabled: false,\n        },\n        xAxis: {\n          categories: [],\n        },\n        yAxis: {\n          categories: [],\n          reversed: false,\n        },\n        accessibility: {\n          point: {\n            descriptionFormat:\n              \"{(add index 1)}. \" +\n              \"{series.xAxis.categories.(x)} \" +\n              \"{series.yAxis.categories.(y)}, {value}.\",\n          },\n        },\n        colorAxis: {\n          min: 0,\n          minColor: \"#FFFFFF\",\n          maxColor: \"#DA70D6\",\n        },\n        tooltip: {\n          style: { color: \"#000\" },\n          formatter() {\n            const addCommas = (value) => {\n              return value.toString().replace(/\\B(?=(\\d{3})+(?!\\d))/g, \",\");\n            };\n            return (\n              `<b>${this.series.xAxis.categories[this.point.x]}</b> had<br>` +\n              `<b>${addCommas(this.point.value)}</b> video views on <br>` +\n              `<b>${this.series.yAxis.categories[this.point.y]}</b>`\n            );\n          },\n        },\n        series: [\n          {\n            name: \"Video Views\",\n            borderWidth: 1,\n            data: [],\n            dataLabels: {\n              enabled: true,\n              color: \"#000000\",\n              formatter() {\n                const numericSymbols = [\"K\", \"M\", \"G\", \"T\", \"P\", \"E\"];\n                if (this.point.value >= 1000) {\n                  const symbolIndex = Math.floor(\n                    Math.log10(this.point.value) / 3\n                  );\n                  const scaledValue =\n                    this.point.value / Math.pow(1000, symbolIndex);\n                  const symbol = numericSymbols[symbolIndex - 1];\n                  return `${Math.ceil(scaledValue)}${symbol}`;\n                }\n                return this.point.value;\n              },\n            },\n          },\n        ],\n        responsive: {\n          rules: [\n            {\n              condition: {\n                maxWidth: 500,\n              },\n              chartOptions: {\n                yAxis: {\n                  labels: {\n                    format: \"{substr value 0 1}\",\n                  },\n                },\n              },\n            },\n          ],\n        },\n      },\n      fullData: [],\n    };\n  },\n  watch: {\n    chartData: {\n      handler(newChartData, oldChartData) {\n        if (newChartData !== oldChartData) {\n          this.updateChartData(newChartData);\n        }\n      },\n      deep: true,\n    },\n  },\n  created() {\n    this.updateChartData(this.chartData);\n  },\n  methods: {\n    updateChartData(data) {\n      this.fullData = data;\n      // console.log(this.fullData);\n      const filteredData = this.fullData.map((item) => ({\n        division: item[this.divisionProp],\n        service: item[this.serviceProp],\n        profile_name: item[this.profileNameProp],\n        report_date: item[this.reportDateProp],\n        insight_video_views: item[this.videoViewsProp],\n      }));\n\n      const generateDateRanges = (fullData) => {\n        const dates = [...new Set(fullData.map((dt) => dt.report_date))].sort();\n        const startDate = moment(dates[0]);\n        const endDate = moment(dates[dates.length - 1]);\n\n        const diffDays = endDate.diff(startDate, \"days\");\n        const diffMonths = endDate.diff(startDate, \"months\");\n\n        const sumInsightVideoViews = (start, end, division) =>\n          fullData\n            .filter(\n              (dt) =>\n                dt.division === division &&\n                moment(dt.report_date).isBetween(start, end, null, \"[)\")\n            )\n            .reduce((sum, dt) => sum + dt.insight_video_views, 0);\n\n        const uniqueDivisions = [...new Set(fullData.map((dt) => dt.division))];\n        const ranges = [];\n\n        uniqueDivisions.forEach((division) => {\n          let current = startDate.clone();\n\n          while (current.isBefore(endDate) || current.isSame(endDate, \"day\")) {\n            let next;\n            let format;\n\n            if (diffDays <= 14) {\n              next = current.clone().add(1, \"day\");\n              format = \"ll\";\n            } else if (diffMonths <= 6) {\n              current.startOf(\"week\");\n              next = current.clone().add(1, \"week\");\n              format = \"ll\";\n            } else {\n              current.startOf(\"month\");\n              next = current.clone().add(1, \"month\");\n              format = \"MMMM, YYYY\";\n            }\n\n            ranges.push({\n              division,\n              date: current.format(format),\n              insight_video_views: sumInsightVideoViews(\n                current,\n                next,\n                division\n              ),\n            });\n\n            current = next;\n          }\n        });\n\n        return ranges;\n      };\n\n      let yAxis = [\n        ...new Set(generateDateRanges(filteredData).map((d) => d.date)),\n      ];\n      let xAxis = [\n        ...new Set(generateDateRanges(filteredData).map((d) => d.division)),\n      ];\n\n      this.chartOptions.yAxis.categories = yAxis;\n      this.chartOptions.xAxis.categories = xAxis;\n\n      const groupedRanges = generateDateRanges(filteredData).reduce(\n        (acc, range) => {\n          if (!acc[range.division]) {\n            acc[range.division] = [];\n          }\n          acc[range.division].push(range);\n          return acc;\n        },\n        {}\n      );\n\n      const matrix = Object.keys(groupedRanges).flatMap((division) => {\n        const divisionIndex = xAxis.indexOf(division);\n        return groupedRanges[division].map((range, dateIndex) => [\n          divisionIndex,\n          dateIndex,\n          range.insight_video_views,\n        ]);\n      });\n\n      this.chartOptions.series[0].data = matrix;\n      console.log(JSON.stringify(this.chartOptions));\n    },\n  },\n};\n</script>\n"],"mappings":";;;uBACEA,mBAAA,CAOM,cANJC,YAAA,CAKcC,qBAAA;IAJX,kBAAgB,EAAE,YAAY;IAC/BC,KAAK,EAAC,IAAI;IACTC,OAAO,EAAEC,KAAA,CAAAC,YAAY;IACtBC,GAAG,EAAC","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}