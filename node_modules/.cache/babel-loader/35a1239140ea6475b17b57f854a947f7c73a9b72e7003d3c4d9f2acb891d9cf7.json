{"ast":null,"code":"import { resolveComponent as _resolveComponent, createVNode as _createVNode, openBlock as _openBlock, createElementBlock as _createElementBlock } from \"vue\";\nexport function render(_ctx, _cache, $props, $setup, $data, $options) {\n  const _component_highcharts = _resolveComponent(\"highcharts\");\n  return _openBlock(), _createElementBlock(\"div\", null, [_createVNode(_component_highcharts, {\n    \"constructor-type\": 'stockChart',\n    class: \"hc\",\n    options: $data.chartOptions,\n    ref: \"chart\"\n  }, null, 8, [\"options\"])]);\n}","map":{"version":3,"names":["_createElementBlock","_createVNode","_component_highcharts","class","options","$data","chartOptions","ref"],"sources":["/Users/rashmee/Desktop/usagm/heatmap/src/components/MainNegativeColumns.vue"],"sourcesContent":["<template>\n  <div>\n    <highcharts\n      :constructor-type=\"'stockChart'\"\n      class=\"hc\"\n      :options=\"chartOptions\"\n      ref=\"chart\"\n    ></highcharts>\n  </div>\n</template>\n\n<script>\nimport moment from \"moment\";\n\nexport default {\n  props: {\n    chartData: {\n      type: Array,\n      default: () => [],\n    },\n    properties: {\n      type: Array,\n      default: () => [],\n    },\n  },\n  data() {\n    return {\n      chartOptions: {\n        chart: {\n          backgroundColor: \"#fbfcf8\",\n          type: \"column\",\n          zoomType: \"x\",\n          height: \"100%\",\n        },\n        title: {\n          text: \"Fans Change\",\n          align: \"center\",\n        },\n        accessibility: {\n          enabled: false,\n        },\n        exporting: {\n          enabled: true,\n          buttons: {\n            contextButton: {\n              menuItems: [\n                \"viewFullscreen\",\n                \"printChart\",\n                \"separator\",\n                \"downloadPNG\",\n                \"downloadJPEG\",\n                \"separator\",\n                \"downloadPDF\",\n                \"downloadCSV\",\n              ],\n            },\n          },\n        },\n        credits: {\n          enabled: false,\n        },\n        legend: {\n          enabled: true,\n          itemStyle: {\n            color: \"#000\",\n          },\n        },\n        rangeSelector: {\n          enabled: false,\n        },\n        navigator: {\n          enabled: false,\n        },\n        scrollbar: {\n          enabled: false,\n        },\n        xAxis: {\n          tickInterval: 2,\n          categories: [],\n          labels: {\n            style: {\n              color: \"#000\",\n            },\n          },\n          lineColor: \"#000\",\n          lineWidth: 3,\n          showLastLabel: false,\n          startOnTick: true,\n          endOnTick: true,\n        },\n        yAxis: {\n          gridLineColor: \"#fbfcf8\",\n          lineColor: \"#000\",\n          lineWidth: 3,\n          showFirstLabel: false,\n          labels: {\n            style: {\n              color: \"#000\",\n            },\n            formatter() {\n              const numericSymbols = [\"K\", \"M\", \"G\", \"T\", \"P\", \"E\"];\n\n              if (this.value >= 1000) {\n                const symbolIndex = Math.floor(Math.log10(this.value) / 3);\n                const scaledValue = this.value / Math.pow(1000, symbolIndex);\n                const symbol = numericSymbols[symbolIndex - 1];\n                return `${scaledValue}${symbol}`;\n              }\n\n              return this.value;\n            },\n          },\n          title: {\n            text: \"\",\n          },\n          opposite: false,\n        },\n        tooltip: {\n          backgroundColor: \"#fbfcf8\",\n          style: { color: \"#000\" },\n          formatter() {\n            return (\n              `<b><u>${moment(this.x).format(\n                \"ddd, MMM D YYYY\"\n              )}</u></b><br/><br/>` +\n              this.points\n                .map(\n                  (point) => `${point.series.name}: ${point.y.toLocaleString()}`\n                )\n                .join(\"<br/>\")\n            );\n          },\n          shared: true,\n          useHTML: true,\n        },\n        plotOptions: {\n          column: {\n            borderRadius: \"25%\",\n          },\n        },\n        series: [],\n      },\n      fullData: [],\n    };\n  },\n  watch: {\n    chartData: {\n      handler(newChartData, oldChartData) {\n        if (newChartData !== oldChartData) {\n          this.updateChartData(newChartData);\n        }\n      },\n      deep: true,\n    },\n  },\n  created() {\n    this.updateChartData(this.chartData);\n  },\n  methods: {\n    updateChartData(data) {\n      this.fullData = data;\n      const categories = [\n        ...new Set(\n          this.fullData\n            .map((dt) => moment(dt.report_date).format(\"ll\"))\n            .sort(\n              (a, b) => moment(a, \"ll\").valueOf() - moment(b, \"ll\").valueOf()\n            )\n        ),\n      ];\n\n      const transformedData = this.getPropertiesSeries();\n\n      this.chartOptions.xAxis.categories = categories;\n      this.chartOptions.series = transformedData;\n    },\n    getPropertiesSeries() {\n      return this.properties.map(({ prop, color, yAxis }) => {\n        const groupedData = this.fullData.reduce((acc, item) => {\n          const date = item.report_date;\n          if (!acc[date]) {\n            acc[date] = {};\n          }\n          acc[date][prop] = (acc[date][prop] || 0) + item[prop];\n          return acc;\n        }, {});\n\n        const aggregatedValues = Object.entries(groupedData).map(\n          ([date, values]) => ({\n            name: moment(date).format(\"lll\"),\n            y: values[prop],\n          })\n        );\n\n        return {\n          name: prop\n            .split(\"_\")\n            .map((word) => word.charAt(0).toUpperCase() + word.slice(1))\n            .join(\" \"),\n          data: aggregatedValues,\n          color: color,\n          yAxis: yAxis || 0,\n        };\n      });\n    },\n  },\n};\n</script>\n"],"mappings":";;;uBACEA,mBAAA,CAOM,cANJC,YAAA,CAKcC,qBAAA;IAJX,kBAAgB,EAAE,YAAY;IAC/BC,KAAK,EAAC,IAAI;IACTC,OAAO,EAAEC,KAAA,CAAAC,YAAY;IACtBC,GAAG,EAAC","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}